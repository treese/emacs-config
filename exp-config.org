#+TITLE: Experimental Emacs configuration
#+PROPERTY: header-args :results none

I like to keep some new parts of the configuration in a separate file so I can review them later before adding them to the permanent configuration. This is the file of experiments.

* BibTeX configuration (experimental)
** Figuring out where cleaning goes wrong                             :blog:
Sometimes cleaning a BibTeX entry changes something in a way I don't like. Since there are 18 functions on ~org-ref-clean-bibtex-entry-hook~, coming from ~bibtex-mode~, ~org-ref~, and my own code, it's a little hard to tell what happened.

This is a modified version of ~org-ref-clean-bibtex-entry~ that watches an entry for changes, and stops when one of them changes the entry. To use it, I usually edit the entry back to the way I wanted it, and run this with ~M-x~.

#+BEGIN_SRC emacs-lisp
(defun wt/trace-org-ref-clean-bibtex-entry ()
  "Clean and replace the key in a bibtex entry.
See functions in `org-ref-clean-bibtex-entry-hook'. Run one
function at a time to figure out which one is making a change."
  (interactive)
  (let (orig)
    (save-excursion
      (save-restriction
        (bibtex-narrow-to-entry)
        (bibtex-beginning-of-entry)
        (setq orig (buffer-substring-no-properties (point-min)
                                                   (point-max)))
        ;; run hooks. each of these operates on the entry with no arguments.
        ;; this did not work like  i thought, it gives a symbolp error.
        ;; (run-hooks org-ref-clean-bibtex-entry-hook)
        (catch 'found-it
          (mapc
           (lambda (x)
             (save-restriction
               (save-excursion
                 (funcall x)))
             (unless
                 (equal orig
                        (buffer-substring-no-properties (point-min)
                                                        (point-max)))
               (message "Modified by %s" x)
               (throw 'found-it x)))
           org-ref-clean-bibtex-entry-hook))))))
#+END_SRC
** Tweak how BibTeX fields are filled                                 :blog:
When BibTeX tries to fill a field to make it look nice, it will move an unfillable one, like a long URL, to the following line before giving up. For example,
#+BEGIN_EXAMPLE
@Online{Smith-2019-Stuff,
  url      = {http:/example.com/a-really-long-url-name-probably-with-random-chars}
}
#+END_EXAMPLE

gets filled as
#+BEGIN_EXAMPLE
@Online{Smith-2019-Stuff,
  url          =
                  {http:/example.com/a-really-long-url-name-probably-with-random-chars}
}
#+END_EXAMPLE

This is sort of pointless, and looks ugly on the screen. It wouldn't happen if ~fill-column~ had a big value, since the helper code of ~fill-paragraph~ is actually doing the work. So we can advise ~bibtex-fill-field-bounds~ (which is the key function called along the way) to do just that.

For the moment, I'm only checking if there are any spaces at all in the field value. We'll see if that's sufficient in practice.
#+BEGIN_SRC emacs-lisp
(defun wt/dont-fill-if-it-wont-work (orig-func bounds justify move)
  "Don't fill a BibTex field if there aren't any spaces.
If the field can't be broken up, there's no point in filling it.
This is done by temporarily binding `fill-column` to a large
number. This function is used to advise
`bibtex-fill-field-bounds', calling ORIG-FUNC with BOUNDS, JUSTIFY, and
MOVE."
  (let* ((bounds-string (buffer-substring-no-properties
                         (bibtex-start-of-field bounds)
                         (bibtex-end-of-field bounds)))
         (field-value (s-trim (cadr (s-split-up-to "=" bounds-string 1))))
         (fill-column (if (string-match split-string-default-separators
                                        field-value)
                          fill-column
                        1000)))
    (message "Value: %s" field-value)
    (funcall orig-func bounds justify move)))

(advice-add 'bibtex-fill-field-bounds
            :around #'wt/dont-fill-if-it-wont-work)
#+END_SRC
